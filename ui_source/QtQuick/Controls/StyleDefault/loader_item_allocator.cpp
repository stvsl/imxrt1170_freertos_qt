// This code is auto-generated by Qul's qmltocpp tool.
// WARNING! All changes made in this file will be lost!
#include "ProgressBar.h"
#include "CheckBox.h"
#include "Slider.h"
#include "SwipeView.h"
#include "Switch.h"
#include "RadioButton.h"
#include "Dial.h"
#include "Button.h"


#include <qul/private/unicodestring.h>
#include <qul/private/file.h>
#include <qul/private/items/itembase.h>

namespace QtQuick {
namespace Controls {
namespace StyleDefault {

struct LoaderItemAppRelativePathCallbackItemData {
    LoaderItemAppRelativePathCallbackItemData()
        : item(NULL)
    {
    }

    Qul::Private::Items::ItemBase *item;
};

static bool loaderItemAppRelativePathCallback(const Qul::Private::String &relativePath, void *data)
{
    LoaderItemAppRelativePathCallbackItemData *d = static_cast<LoaderItemAppRelativePathCallbackItemData *>(data);

    Qul::PlatformInterface::MemoryAllocator *allocator = Qul::Platform::getPlatformInstance()->memoryAllocator(Qul::PlatformInterface::MemoryAllocator::QmlDynamicObjects);

    static const char * const visualItemUrls[] = {
        "Button.qml",
        "CheckBox.qml",
        "Dial.qml",
        "ProgressBar.qml",
        "RadioButton.qml",
        "Slider.qml",
        "SwipeView.qml",
        "Switch.qml",
    };

    static const size_t visualItemUrlLengths[] = {
        10,
        12,
        8,
        15,
        15,
        10,
        13,
        10,
    };

    static const size_t visualItemSizes[] = {
        sizeof(Button),
        sizeof(CheckBox),
        sizeof(Dial),
        sizeof(ProgressBar),
        sizeof(RadioButton),
        sizeof(Slider),
        sizeof(SwipeView),
        sizeof(Switch),
    };

    for (int i = 0; i < 8; ++i) {
        if (relativePath == Qul::Private::String(Qul::Private::Latin1String(visualItemUrls[i], visualItemUrlLengths[i]))) {
            Qul::Private::Items::ItemBase *element = static_cast<Qul::Private::Items::ItemBase *>(allocator->allocate(visualItemSizes[i]));
            if (!element) return false;
            switch (i) {
            case 0: new (element) Button; break;
            case 1: new (element) CheckBox; break;
            case 2: new (element) Dial; break;
            case 3: new (element) ProgressBar; break;
            case 4: new (element) RadioButton; break;
            case 5: new (element) Slider; break;
            case 6: new (element) SwipeView; break;
            case 7: new (element) Switch; break;
            }
            d->item = element;
        }
    }

    static const char * const nonVisualItemUrls[] = {
        "DefaultStyle.qml",
    };

    static const size_t nonVisualItemUrlLengths[] = {
        16,
    };

    static const char * const nonVisualItemBaseTypes[] = {
        "QtObject",
    };

    for (int i = 0; i < 1; ++i) {
        if (relativePath == Qul::Private::String(Qul::Private::Latin1String(nonVisualItemUrls[i], nonVisualItemUrlLengths[i]))) {
            Qul::PlatformInterface::log("[Loader Error] Failed to load nonvisual item '%s' in '%s'."
                                        " Wrap '%s' in 'Item' item.\n", nonVisualItemBaseTypes[i], nonVisualItemUrls[i], nonVisualItemBaseTypes[i]);
        }
    }

    if (d->item)
        return true;

    Qul::PlatformInterface::log("failed to load item from: %s\n", relativePath.maybeUtf8());
    return false;
}

Qul::Private::Items::ItemBase *loaderItemAllocator(const Qul::Private::String &uri, const Qul::Private::String &currentFileDir)
{
    if (uri.isEmpty())
        return NULL;

    LoaderItemAppRelativePathCallbackItemData loaderData;

    bool ok = Qul::Private::appRelativePath(uri, currentFileDir, loaderItemAppRelativePathCallback, &loaderData);
    QUL_UNUSED(ok);

    return loaderData.item;
}

} // namespace QtQuick
} // namespace Controls
} // namespace StyleDefault
